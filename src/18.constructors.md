[https://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html](https://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html)

# 构造方法

用法跟 method 相似，区别是没有返回值。比方说：

```java
public Bicycle(int startCadence,int startSpeed,int startGear){
  gear = startGear;
  cadence = startCadence;
  speed = startSpeed;
}
```

此时可以用 Bicycle myBike = new Bicycle(30,0,8); 来初始化；

尽管只有一个 constructor，但还可以有无参数的 constructor：

```java
public Bicycle(){
  gear = 1;
  cadence = 10;
  speed = 0;
}

// 调用

Bicycle myBike = new Bicycle();
```

由于它们有不同的参数列表，这两种构造函数都能够被声明，具体参照方法重载时的注意事项；

不是所有的类都需要提供构造函数，但要提供的时候需要小心处理。编译器会自动提供一个无参数的构造函数。

# 方法、构造函数传参

[https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html](https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html)

```java
public double computePayment(
                  double loanAmt,
                  double rate,
                  double futureValue,
                  int numPeriods) {
    double interest = rate / 100.0;
    double partial1 = Math.pow((1 + interest),
                    - numPeriods);
    double denominator = (1 - partial1) / interest;
    double answer = (-loanAmt / denominator)
                    - ((futureValue * partial1) / denominator);
    return answer;
}

```

# 参数类型

支持任何类型

> 如果想传一个 method 到另一个 method 里面，可以用 lambda expression 或者方法引用 method reference

## 函数表达式

> Lambda expressions enable you to do this, to treat functionality as method argument, or code as data.

比如

```java
public class Person {

    public enum Sex {
        MALE, FEMALE
    }

    String name;
    LocalDate birthday;
    Sex gender;
    String emailAddress;

    public int getAge() {
        // ...
    }

    public void printPerson() {
        // ...
    }
}
```

## 传参，类

```java
public static void printPersonsOlderThan(List<Person> roster, int age) {
    for (Person p : roster) {
        if (p.getAge() >= age) {
            p.printPerson();
        }
    }
}
```

强耦合，如果 Person 定义变更时，需要大量的调整；

### 通用化的方案

```java
public static void printPersonsWithAgeRange(List<Person> roster,int low,int high){
  for(Person p:roster){
    if (low <= p.getAge() && p.getAge() < high) {
          p.printPerson();
      }
  }
}

```

如果需要查找 olderThan 或者 youngerThan 时，需要改方法，这里做一层抽象：

```java
public static void printPersons(List<Person> roster,CheckPerson tester){
  for(Person p :roster){
    if( tester.test(p) ){
      p.printPerson();
    }
  }
}


interface CheckPerson {
    boolean test(Person p);
}
```

```java

class CheckPersonEligibleForSelectiveService implements CheckPerson{
  public boolean test(Person p){
    return p.gender == Person.Sex.MALE && p.getAge() >=18 && p.getAge() <=25;
  }
}

// 调用
printPersons(
    roster, new CheckPersonEligibleForSelectiveService());

```
